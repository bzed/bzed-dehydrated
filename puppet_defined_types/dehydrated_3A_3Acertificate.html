<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Defined Type: dehydrated::certificate
  
    &mdash; Documentation by YARD 0.9.36
  
</title>

  <link rel="stylesheet" href="../css/style.css" type="text/css" />

  <link rel="stylesheet" href="../css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "puppet_defined_types::dehydrated::certificate";
  relpath = '../';
</script>


  <script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../puppet_defined_type_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../_index.html">Index (d)</a> &raquo;
    <span class='title'><span class='object_link'>Defined Types</span></span>
     &raquo; 
    <span class="title">dehydrated::certificate</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="puppet_class_list_link"
        href="../puppet_class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Defined Type: dehydrated::certificate</h1>
<div class="box_info">
  <dl>
    <dt>Defined in:</dt>
    <dd>
      manifests/certificate.pp
    </dd>
  </dl>
</div>

  <h2>Summary</h2>
  Creates key & csr and request the certificate.

<h2>Overview</h2>
<div class="docstring">
  <div class="discussion">
    <p>Triggers key and csr generation and requests the certificate
via the host configured in $dehydrated_host.
This is the main defined type to use if you want to have a
certificate. Together with the defaults in the dehydrated
class you should have everything to make requesting certificates
possible. Especially the dehydrated::certificate::* types do not
have a public API and can change without warning. Don&#39;t rely on
them.
Dehydrated::Certificate[$dn] is also what you want to use to
subscribe to if you want to restart services after certificates
have been installed/updated.</p>

  </div>
</div>



<div class="tags">
  
  <div class="examples">
    <p class="tag_title">Examples:</p>
    
      
      <pre class="example code"><code>dehydrated::certificate { &#39;test.example.com&#39;: }</code></pre>
    
  </div>
<p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>dn</span>
      
      
        <span class='type'>(<tt>Dehydrated::DN</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>$name</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>The main distinguished name to use for the certificate.
Defaults to $name.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>base_filename</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>regsubst($dn, &#39;^\*&#39;, &#39;_wildcard_&#39;)</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>The base part of the filename of all related files.
For wildcard certificates the * is replaced by <em>wildcard</em>.
Feel free to use whatever a valid filename is.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>subject_alternative_names</span>
      
      
        <span class='type'>(<tt>Array[Dehydrated::DN]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>[]</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>To request a SAN certificate, pass an array with the
alternative names here. The main $dn will be added automatically.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>challengetype</span>
      
      
        <span class='type'>(<tt>Dehydrated::Challengetype</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>$dehydrated::challengetype</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>Default challengetype to use. Defaults to $dehydrated::challengetype,
which defaults to &#39;dns-01&#39;. You can specify a different
challengetype for each certificate here.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>algorithm</span>
      
      
        <span class='type'>(<tt>Dehydrated::Algorithm</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>$dehydrated::algorithm</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>Algorithm / elliptic-curve you want to use. Supported: rsa, secp384r1, prime256v1.
Defaults to $dehydrated::algorithm, which defaults to &#39;rsa&#39;.
You can specify a different algorithm for each certificate here.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>dh_param_size</span>
      
      
        <span class='type'>(<tt>Integer[768]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>$dehydrated::dh_param_size</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>Size of the DH params we should generate. Defaults to $dehydrated::dh_param_size,
which defaults to 2048. You can specify a different DH param size for each certificate here.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>dehydrated_host</span>
      
      
        <span class='type'>(<tt>Stdlib::Fqdn</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>$dehydrated::dehydrated_host</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>$::fqdn of the host which is responsible to request the certificates from
the Let&#39;s Encrypt CA. Defaults to $dehydrated::dehydrated_host where you can
configure your default.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>dehydrated_environment</span>
      
      
        <span class='type'>(<tt>Hash</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>$dehydrated::dehydrated_environment</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>Hash with the environment variables to set for the $dehydrated_domain_validation_hook
and also for running the hook in dehydrated.
Defaults to $dehydrated::dehydrated_environment, empty by default.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>dehydrated_hook</span>
      
      
        <span class='type'>(<tt>Optional[Dehydrated::Hook]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>$dehydrated::dehydrated_hook</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>Name of the hook script you want to use. Can be left on undef if http-01 is being
used as challengetype to use the built-in http-01 implementation of dehydrated.
Defaults to $dehydrated::dehydrated_hook, which will use &quot;$challengetype.sh&quot;
if the challengetype is not http-01.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>letsencrypt_ca</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>$dehydrated::letsencrypt_ca</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>Defines the CA you want to use to request certificates. If you want to use a
non-supported CA, you need to configure it in $dehydrated::letsencrypt_cas on
your $dehydrated_host.
Normally, the following CAs are pre-configured:
staging, production, v2-staging, v2-production
Defaults to $dehydrated::letsencrypt_ca, which points to v2-production.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>dehydrated_domain_validation_hook</span>
      
      
        <span class='type'>(<tt>Optional[Dehydrated::Hook]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>$dehydrated::dehydrated_domain_validation_hook</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>Name of the hook script to run before dehydrated is actually executed.
Used to check if a domain is still valid or if you are allowed to modify it.
Or whatever else you want to do as preparation.
Good thing to use before running into limits by trying to request
certificates for domains you don&#39;t own.
Defaults to $dehydrated::dehydrated_domain_validation_hook where you
can configure the default for your setup.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>key_password</span>
      
      
        <span class='type'>(<tt>Optional[String]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>undef</tt>)</em>
      
      
        &mdash;
        <div class='inline'><p>If your key should be protected by a password, specify it here.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>preferred_chain</span>
      
      
        <span class='type'>(<tt>Optional[String]</tt>)</span>
      
      
        <em class="default">(defaults to: <tt>$dehydrated::preferred_chain</tt>)</em>
      
      
    </li>
  
</ul>



</div><div class="method_details_list">
  <table class="source_code">
    <tr>
      <td>
        <pre class="lines">


72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135</pre>
      </td>
      <td>
        <pre class="code"><span class="info file"># File 'manifests/certificate.pp', line 72</span>

define dehydrated::certificate (
  Dehydrated::DN $dn = $name,
  String $base_filename = regsubst($dn, &#39;^\*&#39;, &#39;_wildcard_&#39;),
  Array[Dehydrated::DN] $subject_alternative_names = [],
  Dehydrated::Challengetype $challengetype = $dehydrated::challengetype,
  Dehydrated::Algorithm $algorithm = $dehydrated::algorithm,
  Integer[768] $dh_param_size = $dehydrated::dh_param_size,
  Stdlib::Fqdn $dehydrated_host = $dehydrated::dehydrated_host,
  Hash $dehydrated_environment = $dehydrated::dehydrated_environment,
  Optional[Dehydrated::Hook] $dehydrated_hook = $dehydrated::dehydrated_hook,
  String $letsencrypt_ca = $dehydrated::letsencrypt_ca,
  Optional[Dehydrated::Hook] $dehydrated_domain_validation_hook = $dehydrated::dehydrated_domain_validation_hook,
  Optional[String] $key_password = undef,
  Optional[String] $preferred_chain = $dehydrated::preferred_chain,
) {
  if ! defined(Class[&#39;dehydrated&#39;]) {
    fail(&#39;You must include the dehydrated base class first.&#39;)
  }

  require dehydrated::setup
  require dehydrated::params

  # ensure $dn is also in subject_alternative_names
  $_subject_alternative_names = unique(flatten([$dn, $subject_alternative_names]))

  $domain_config = {
    $dn =&gt; {
      &#39;subject_alternative_names&#39;         =&gt; $_subject_alternative_names,
      &#39;base_filename&#39;                     =&gt; $base_filename,
      &#39;dh_param_size&#39;                     =&gt; $dh_param_size,
      &#39;challengetype&#39;                     =&gt; $challengetype,
      &#39;dehydrated_host&#39;                   =&gt; $dehydrated_host,
      &#39;dehydrated_environment&#39;            =&gt; $dehydrated_environment,
      &#39;dehydrated_hook&#39;                   =&gt; $dehydrated_hook,
      &#39;dehydrated_domain_validation_hook&#39; =&gt; $dehydrated_domain_validation_hook,
      &#39;letsencrypt_ca&#39;                    =&gt; $letsencrypt_ca,
      &#39;preferred_chain&#39;                   =&gt; $preferred_chain,
    },
  }

  $json_fragment = to_json($domain_config)
  ::concat::fragment { &quot;${facts[&#39;networking&#39;][&#39;fqdn&#39;]}-${dn}&quot; :
    target  =&gt; $dehydrated::params::domainfile,
    content =&gt; $json_fragment,
    order   =&gt; &#39;50&#39;,
  }

  dehydrated::certificate::csr { $base_filename :
    dn                        =&gt; $dn,
    subject_alternative_names =&gt; $subject_alternative_names,
    key_password              =&gt; $key_password,
    algorithm                 =&gt; $algorithm,
  }

  $ready_for_merge = pick(
    $facts.dig(&#39;dehydrated_domains&#39;, $dn, &#39;ready_for_merge&#39;),
    false
  )
  if $ready_for_merge {
    dehydrated::certificate::deploy { $dn :
      key_password =&gt; $key_password,
    }
  }
}</pre>
      </td>
    </tr>
  </table>
</div>
</div>

      <div id="footer">
     Generated by <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>.
</div>

    </div>
  </body>
</html>